-# coding: UTF-8


%div.row
  %div.span12
    %h1 Green Shoes'un Kuralları
    %h3
      Green Shoes'un nasıl çalıştığını tahmin etmeyi bırakalım. Bazı hassa noktalar 
      sizi zorlayabilir. Aşağıda Green Shoes'un esas kurallarını sıraladım. Bunları 
      her şeyi sağlıklı çalıştırmak için 
      %b MUTLAKA 
      öğrenmelisiniz
    %hr
    %br
    %p 
      Bunlar tüm Green Shoes içindeki genel kurallar. Green Shoes basitlik ve açıklık 
      üzerine kurulduğu için, çalışılacak ve hatırlanacak bir kaç nokta vardır.
    %h1 Shoes İncelikli Bloklar
    %p
      Tamam, burası biraz çetrefilli. Green Shoes bloklarla biraz enteresan davranır. 
      Bu enteresanlık sayesinde kodun okunabilirliği artar. Ama aynı zamanda 
      biraz derinlere dalınca kullanımı güçleştirir.
    %h4 Şimdi bir normal Ruby bloğuna bakalım:
    :coderay
      #!Ruby
      Shoes.app do
        ary = ['potion', 'swords', 'shields']
        ary.each do |item|
          puts item
        end
      end
    %br
    
    %p
      Green Shoes'da bu tip bloklar aynı çalışır. Yukardaki blok bir array 
      elemanları üzerinden bir çevrime girer ve herbirini 
      %code item 
      değişkenine alarak işler. Blok işlenmesi bittiğinde 
      %code item 
      değişkeni de yok olur.
    %p
      Akılda tutulması gereken bir başka nokta da 
      %code self 
      normal Ruby blokları arasında değerini korur. Yani 
      %code each 
      bloğundan önce 
      %code self 
      ne değerdeyse blok içinde de aynı değerdedir.
    %h4 Bu iki nokta birçok Green Shoes bloğu için de geçerlidir.
    :coderay
      #!Ruby
      Shoes.app do
        stack do
          para "First"
          para "Second"
          para "Third"
        end
      end
    %br
    
    %p
      Burada iki bloğumuz var. İlk blok 
      %code Shoes.app 
      nesnesine gönderilir ve bu 
      %code self 
      i değiştirir.
    %p
      Diğer blok ise 
      %code stack 
      bloğu. Bu blok self'i değiştirmez.
    %p
      %b Ne sebeple 
      %code app
      %b bloğu self'i değiştirir? 
      Son örneğimizi irdeleyerek başlayalım.
    %br
    :coderay
      #!Ruby
      Shoes.app do
        self.stack do
          self.para "First"
          self.para "Second"
          self.para "Third"
        end
      end
    %br
    
    %p
      Buradaki tüm 
      %code self 
      ler App nesnesini temsil ediyor. Green Shoes 
      %code app 
      bloğu içinde self'i değiştirmek için 
      %code instance_eval 
      metodunu kullanır. Bu yüzden stack ve para metodlarına yapılan çağrılar 
      app'ye gönderilir.
    %h4 Bu sayede oluşum değişkenleri tüm Shoes uygulaması içinde kullanılabilir:
    :coderay
      #!Ruby
      Shoes.app do
        @s = stack do
          @p1 = para "First"
          @p2 = para "Second"
          @p3 = para "Third"
        end
      end
    %br
    
    %p Bu tüm oluşum değişkenleri App nesnesi içinde geçerlidir.
    %h4
      Yeni bir Shoes.app penceresi üretince 
      %code self 
      değişir.
    :coderay
      #!Ruby
      Shoes.app title: "MAIN" do
        para self
        button "Spawn" do
          Shoes.app title: "CHILD" do
            para self
          end
        end
      end
    %br
    %br
    
    %h1 Blok Yönlendirmesi
    %p
      %code stack 
      bloğu başka bir hikaye. Bu blok 
      %code self 
      i değiştirmez ve normal bir blokdur.
    %p
      %b Fakat bir ince nokta var: 
      Bir 
      %code stack 
      üretir ve ona bir blok bağlarsanız, App nesnesi bu stack'i hafızasına 
      yerleştirir. Blok bitince bu stack de biter. Ve blok içindeki tüm çizimler 
      App'nin en üst rafından yeni stack içine yönlendirilir.
    %br
    
    :coderay
      #!Ruby
      Shoes.app do
        stack do
          para "First"
          para "Second"
          para "Third"
        end
      end
    %br
    
    %p Biraz çetrefilli dimi , bu konu bilseniz bile size sorun çıkarabilir.
    %p
      Sizi avlayacağı yerlerden biri , eğer 
      %code app
      bloğu dışında bir yerde stack düzenlemeye kalkarsanız olacaktır.
    %p
      Mesela , bir stack nesnesini alıp düzenlemek için başka bir sınıfa 
      gönderiyorsunuz.
    %br
    
    :coderay
      #!Ruby
      class Messenger
        def initialize slot
          @slot = slot
        end
        
        def add msg
          para msg rescue puts $!
        end
      end
      
      Shoes.app do
        slot = stack
        m = Messenger.new slot
        m.add 'hello'
      end
    %br
    
    %p
      Diyelim uygulama başladığında stack nesnenizi Messenger sınıfınıza 
      gönderdiniz. Ve sonra yeni mesaj gelince 
      %b add 
      metodu bu stack'a paragraf ekleyerek mesajı yazıyor. Sorun var mı, yok?
    %p
      Maalesef, bu çalışmaz. 
      %b para 
      metodunun anlaşılmadığını belirtir bir mesaj verecektir. Çünkü 
      %b App 
      nesnesi içinde değil. Metod App'ye ait habuki.
    %p
      Ne güzel ki, her Shoes nesnesi dışardan bu tip müdahaleler amaçlı bir 
      %b app 
      metoduna sahiptir.
    %br
    
    :coderay
      #!Ruby
      class Messenger
        def initialize slot
          @slot = slot
        end
        
        def add msg
          @slot.app do
            para msg rescue puts $!
          end
        end
      end
      
      Shoes.app do
        slot = stack
        m = Messenger.new slot
        m.add 'hello'
      end
    %br
    
    %p
      Tahmin edeceğiniz gibi, 
      %b app 
      metodu 
      %b self' 
      i App nesnesine çevirir.
    %p Bu durumda kurallar:
    %ol
      %li
        %b "app" metodu veya yeni pencere üreten metodlar 
        %code self'
        %b i App nesnesine çevirir.
        %br
        %p
          (Bu 
          %a(href="/kitap/213#window")window 
          ve 
          %a(href="/kitap/213#dialog")dialog'
          da olduğu gibi Shoes.app ve Slot.app'nin 
          her ikisinde de geçerlidir)
      %li
        %b 
          stack, flow veya herhangi manipulasyon metoduna (mesela append) 
          ilişik bloklar self'i değiştirmez. Yerine bloktakileri app'ye geçirirler.
    %br
    %br
    
    %h1 Sabit Yüksekliklere Dikkat Edin
    %p Slotlarda sabit genişlik ekranı sütunlara bölmek için güzel bir fikir.
    %br
    
    :coderay
      #!Ruby
      Shoes.app do
        flow do
          stack :width => 200 do
            background lavender
            caption "Sütun bir"
            para "200 pixel genişlikte"
          end
          stack :width => -200 do
            background bisque
            caption "Sütun iki"
            para "%100 - 200 pixel genişlikte"
          end
        end
      end
    %br
    
    %p
      Sotlarda sabir yükseklik pek kullanılmamalı. Genellikle yazılarınız ve 
      resimlerinizin oldukları kadar aşağı gitmesini istersiniz. Yükseklik genelde 
      doğal şekline bırakılır.
    %p
      Buradaki önemli nokta sabit yükseklikler slotları farklı davranmaya zorlar. 
      Slotun doğru yerden kesildiğine emin olmak için slot bir 
      %b iç pencereye 
      döndürülür. Slotu sabit bir dörtgende tutmak için işletim sistemi 
      tarafından yeni bir katman oluşturulur.
    %p
      Normal slotlar ve iç pencereler arasındaki bir fark, ikincisinin scrollbar 
      alabilmesidir.
    %br
    
    :coderay
      #!Ruby
      Shoes.app do
        stack width: 200, height: 200, scroll: true do
          background "#DFA"
          100.times do |i|
            para "Paragraph No. \#{i}"
          end
          flush
        end
      end
    %br
    
    



    %h3 Devam Edecek...




    %hr
    %a.btn.btn-large.btn-success.pull-left(href="/kitap/202")
      %i.icon-backward.icon-white
      Shoes'a Giriş
    %a.btn.btn-large.btn-success.pull-right(href="/kitap/204")
      Green Shoes'un Kuralları
      %i.icon-forward.icon-white
